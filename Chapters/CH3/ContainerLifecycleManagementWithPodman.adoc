:pygments-style: tango
:source-highlighter: pygments
:toc:
:toclevels: 7
:sectnums:
:sectnumlevels: 6
:numbered:
:chapter-label:
:icons: font
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images/


=== There is a rhel7 container image but not a rhel8 image.  Where is the rhel8 container image?

Try to search and find the RHEL8 base image by searching https://catalog.redhat.com/software/containers/explore/ using the "rhel8" search string.

image::rhel8.png[title="rhel8 search results"]

Of the search results returned, try to find a rhel8 *Scratch* image, one that includes only base RHEL8 software.
You will not find one.  Instead the images available include additional software or configuration The *rhel8/dotnet-31* image, for example, contains the .NET SDK and Runtime as well as standard RHEL8 packages.
This may not be what you are looking for, especially, if you want a "vanilla" or *Scratch* RHEL8 image.

Now, repeat your search using *ubi8*

image::ubi8.png[title="ubi8 container image"]

Starting with RHEL8, Red Hat creates and distributes RHEL container images as *Universal Base Images* or *ubi* images.
If you are looking for a "scratch" image that includes only the standard RHEL8 packages, then look for *ubi* instead of *rhel*.


=== How can you install additional packages using a ubi image?

Inspect first the `ubi.repo` file in the ubi8 image:

[source,bash]
----
[student@workstation ~]$ podman pull registry.access.redhat.com/ubi8
Trying to pull registry.access.redhat.com/ubi8...

[student@workstation ~]$ podman run registry.access.redhat.com/ubi8 cat /etc/redhat-release
Red Hat Enterprise Linux release 8.6 (Ootpa)

[student@workstation ~]$ podman run registry.access.redhat.com/ubi8 cat /etc/yum.repos.d/ubi.repo
[ubi-8-baseos-rpms]
name = Red Hat Universal Base Image 8 (RPMs) - BaseOS
baseurl = https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi8/8/$basearch/baseos/os
enabled = 1
gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release
gpgcheck = 1
----

One interesting and useful feature of ubi images is the ability to install additional software via *yum* without a Red Hat subscription.

Consider running this interactive shell to install *httpd* (apache):

[source,bash]
----
[student@workstation ~]$ podman run -it registry.access.redhat.com/ubi8 /bin/bash
[root@7a6899de957c /]# yum install httpd -y
Updating Subscription Management repositories.
Unable to read consumer identity
Subscription Manager is operating in container mode.

This system is not registered with an entitlement server. You can use subscription-manager to register.

Red Hat Universal Base Image 8 (RPMs) - BaseOS                                                                                2.4 MB/s | 803 kB     00:00
Red Hat Universal Base Image 8 (RPMs) - AppStream                                                                              30 MB/s | 3.0 MB     00:00
Red Hat Universal Base Image 8 (RPMs) - CodeReady Builder                                                                     332 kB/s |  20 kB     00:00
Dependencies resolved.
==============================================================================================================================================================
 Package                           Architecture          Version                                                    Repository                           Size
==============================================================================================================================================================
Installing:
 httpd                             x86_64                2.4.37-47.module+el8.6.0+15654+427eba2e.2                  ubi-8-appstream-rpms                1.4 M
Installing dependencies:
 apr
 ...SNIP...
----

_Works!_ Why? Open your browser to the *baseurl* given in the *ubi8.repo*.  You can insert the x86_64 arch for this example:
https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi8/8/x86_64/baseos/os

image::ubi-repo.png[title="ubi Package Repository"]

SEE also https://access.redhat.com/articles/4238681


=== How are the ubi images created by Red Hat? Do we publish the ubi Containerfile?

The ubi images distributed by Red Hat are not built in the same way a developer may customize one to create a layered image for their application.
Instead, they are created using a tarball extracted from the root filesystem of kickstarted virtual machines.

A good explanation is given in http://crunchtools.com/ubi-build/

[quote]
____
The contents of most base images are created with operating system installers. While many base images utilize a Dockerfile, it probably doesn’t provide what you’re looking for. There’s an underlying chicken and egg problem because without a package manager installed and configured, the step by step instructions of how every file is laid out on disk can’t be easily expressed in a Dockerfile.
____


=== How are the names autogenerated by podman determined ?

Names will be autogenerated for containers with the form adjective_famousperson

SEE the sourcecode: https://github.com/containers/podman/blob/main/vendor/github.com/docker/docker/pkg/namesgenerator/names-generator.go


[source,bash]
----
        left = [...]string{
                "admiring",
                "adoring",
                "affectionate",
                "agitated",
                "amazing",
                "angry",

        right = [...]string{
                // Muhammad ibn Jābir al-Ḥarrānī al-Battānī was a founding father of astronomy. https://en.wikipedia.org/wiki/Mu%E1%B8%A5ammad_ibn_J%C4%81bir_al-%E1%B8%A4arr%C4%81n%C4%AB_al-Batt%C4%81n%C4%AB
                "albattani",

                // Frances E. Allen, became the first female IBM Fellow in 1989. In 2006, she became the first female recipient of the ACMs Turing Award. https://en.wikipedia.org/wiki/Frances_E._Allen
                "allen",

...SNIP...
func main() {
begin:
        rand.Seed(time.Now().UnixNano())
        name := fmt.Sprintf("%s_%s", left[rand.Intn(len(left))], right[rand.Intn(len(right))])
        if name == "boring_wozniak" /* Steve Wozniak is not boring */ {
                goto begin
        }
        fmt.Println(name)
}

----


=== What is actually running inside the httpd image from rhscl?

Run an apache daemon using the `rhscl/httpd-24-rhel7` image.  Add in a name like `myhttpd` so that we can refer to this container later.

[source,bash]
----
[student@workstation ~]$ podman run --name myhttpd -d registry.access.redhat.com/rhscl/httpd-24-rhel7:latest

[student@workstation ~]$ podman ps --no-trunc
CONTAINER ID                                                      IMAGE                                                   COMMAND             CREATED         STATUS             PORTS  NAMES
CONTAINER ID                                                      IMAGE                                                   COMMAND             CREATED         STATUS             PORTS       NAMES
2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422  registry.access.redhat.com/rhscl/httpd-24-rhel7:latest  /usr/bin/run-httpd  11 seconds ago  Up 12 seconds ago              myhttpd
----

The `podman ps` output indicates that `/usr/bin/run-httpd` is the containerized process executed by our container runtime.

To inspect further what is running in a container, we could run another program inside the same namespaces using `podman exec`:

[source,bash]
----
[student@workstation ~]$ podman exec -it myhttpd /bin/bash
bash-4.2$
bash-4.2$ ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
default        1       0  0 14:55 ?        00:00:00 httpd -D FOREGROUND
default       40       1  0 14:55 ?        00:00:00 /usr/bin/cat
default       41       1  0 14:55 ?        00:00:00 /usr/bin/cat
default       42       1  0 14:55 ?        00:00:00 /usr/bin/cat
default       43       1  0 14:55 ?        00:00:00 /usr/bin/cat
default       44       1  0 14:55 ?        00:00:00 httpd -D FOREGROUND
default       45       1  0 14:55 ?        00:00:00 httpd -D FOREGROUND
default       54       1  0 14:55 ?        00:00:00 httpd -D FOREGROUND
default       66       1  0 14:55 ?        00:00:00 httpd -D FOREGROUND
default       69       1  0 14:55 ?        00:00:00 httpd -D FOREGROUND
default       90       0  0 15:09 pts/0    00:00:00 /bin/bash
default       99      90  0 15:10 pts/0    00:00:00 ps -ef
----

What happened to the `run-httpd` processs? pid=1 from the output above indicates `httpd -D FOREGROUND` is running.  No `run-httpd` seems to be running here.

Inspect the contents of `/usr/bin/run-httpd`.  Use `podman exec` like before:

[source,bash]
----
[student@workstation ~]$ podman exec -it myhttpd /bin/bash
bash-4.2$ cat /usr/bin/run-httpd
...SNIP…
process_extending_files ${HTTPD_APP_ROOT}/src/httpd-pre-init/ ${HTTPD_CONTAINER_SCRIPTS_PATH}/pre-init/

exec httpd -D FOREGROUND $@
----

`usr/bin/run-httpd` is a script (a wrapper).  The last command executed is `exec httpd -D FOREGROUND`.  We did see this process and it was pid=1 in this namespace.

The `exec` is important here.  `exec` is a shell (bash) built-in command.  From `man exec`:

[quote]
____
exec [-cl] [-a name] [command [arguments]]
       If  command  is  specified,  it  replaces  the shell.  No new process is created.  The arguments become the arguments to command.
____

In summary, the container runtime executes `/usr/bin/run-httpd` in isolation.  This command then executes `httpd -D FOREGROUND` with the `exec` built-in.  This `httpd` replaces the `run-httpd` process becoming pid=1 in this namespace.


=== How to use a systemd.unit file so that a container is started on system boot?

Assuming you have a container named `myhttpd` defined previously, use `podman generate systemd`

[source,bash]
----
[student@workstation ~]$ podman ps
CONTAINER ID  IMAGE                                                   COMMAND               CREATED         STATUS             PORTS       NAMES
2c3c93d8cfe4  registry.access.redhat.com/rhscl/httpd-24-rhel7:latest  /usr/bin/run-http...  28 minutes ago  Up 28 minutes ago              myhttpd

[student@workstation ~]$ podman generate systemd -n myhttpd
# container-myhttpd.service
# autogenerated by Podman 4.0.2
# Wed Sep 21 14:27:51 EDT 2022

[Unit]
Description=Podman container-myhttpd.service
Documentation=man:podman-generate-systemd(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor=/run/user/1000/containers

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
TimeoutStopSec=70
ExecStart=/usr/bin/podman start myhttpd
ExecStop=/usr/bin/podman stop -t 10 myhttpd
ExecStopPost=/usr/bin/podman stop -t 10 myhttpd
PIDFile=/run/user/1000/containers/overlay-containers/2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422/userdata/conmon.pid
Type=forking

[Install]
WantedBy=default.target
----

This systemd.unit file can used to start and stop the myhttpd container via `systemctl` commands:

[source,bash]
----
[student@workstation ~]$ podman stop myhttpd
[student@workstation ~]$ mkdir -p ~/.config/systemd/user
[student@workstation ~]$ podman generate systemd -n myhttpd > ~/.config/systemd/user/myhttpd.service
[student@workstation ~]$ systemctl --user daemon-reload
[student@workstation ~]$ systemctl --user enable myhttpd.service
[student@workstation ~]$ systemctl --user start myhttpd
[student@workstation ~]$ podman ps
CONTAINER ID  IMAGE                                                   COMMAND               CREATED         STATUS             PORTS       NAMES
2c3c93d8cfe4  registry.access.redhat.com/rhscl/httpd-24-rhel7:latest  /usr/bin/run-http...  30 minutes ago  Up 20 seconds ago              myhttpd

[student@workstation ~]$ systemctl --user status myhttpd
● myhttpd.service - Podman container-myhttpd.service
   Loaded: loaded (/home/student/.config/systemd/user/myhttpd.service; enabled; vendor preset: enabled)
   Active: active (running) since Wed 2022-09-21 14:28:50 EDT; 39s ago
     Docs: man:podman-generate-systemd(1)
  Process: 6294 ExecStart=/usr/bin/podman start myhttpd (code=exited, status=0/SUCCESS)

[student@workstation ~]$ systemctl --user stop myhttpd
[student@workstation ~]$ podman ps
CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES
----

To have this container automatically start on boot you can leverage `loginctl enable-linger`.  You will need to run this with elevated privileges:

[source,bash]
----
[student@workstation ~]$ sudo loginctl enable-linger student
[student@workstation ~]$ sudo reboot
Connection to 172.25.252.1 closed by remote host.
Connection to 172.25.252.1 closed.
(after a reboot)
[student@workstation ~]$ podman ps
CONTAINER ID  IMAGE                                                   COMMAND               CREATED         STATUS                 PORTS       NAMES
2c3c93d8cfe4  registry.access.redhat.com/rhscl/httpd-24-rhel7:latest  /usr/bin/run-http...  34 minutes ago  Up About a minute ago              myhttpd
[student@workstation ~]$ systemctl --user status myhttpd
● myhttpd.service - Podman container-myhttpd.service
   Loaded: loaded (/home/student/.config/systemd/user/myhttpd.service; enabled; vendor preset: enabled)
   Active: active (running) since Wed 2022-09-21 14:31:41 EDT; 1min 37s ago
     Docs: man:podman-generate-systemd(1)
  Process: 1349 ExecStart=/usr/bin/podman start myhttpd (code=exited, status=0/SUCCESS)
 Main PID: 1603 (conmon)
----

SEE also https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/building_running_and_managing_containers/index#proc_enabling-systemd-services_assembly_porting-containers-to-systemd-using-podman


=== How to extract metadata from `podman inspect` ?

Containers and images have a large number of properties defined as part of the OCI specification.  These details are typically not displayed when running commands like `podman ps`.  `podman inspect` can be used to dump all of the properties or keys (metadata) of a container.

[source,bash]
----
[student@workstation ~]$ podman inspect --help
Display the configuration of object denoted by ID

Description:
  Displays the low-level information on an object identified by name or ID.
  For more inspection options, see:

  [student@workstation ~]$ podman ps
  CONTAINER ID  IMAGE                                                   COMMAND               CREATED         STATUS             PORTS       NAMES
  2c3c93d8cfe4  registry.access.redhat.com/rhscl/httpd-24-rhel7:latest  /usr/bin/run-http...  47 minutes ago  Up 14 minutes ago              myhttpd
  [student@workstation ~]$ podman inspect myhttpd | head
  [
       {
            "Id": "2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422",
            "Created": "2022-09-21T13:58:47.711790266-04:00",
            "Path": "container-entrypoint",
            "Args": [
                 "/usr/bin/run-httpd"
            ]

----

`podman inspect` will return a JSON object with all of the `"key": value` pairs included in a container\'s metadata.

There are different techniques for parsing this information.  Some methods use straightforward shell-based approaches piping this data into tools like `grep`, `awk`, and/or `sed`

Suppose you wanted to identify the global PID for the containerized process in the `myhttpd` container.  Some combination of these tools could be used like the following:

[source,bash]
----
[student@workstation ~]$ podman inspect myhttpd | grep -i pid
               "Pid": 1614,
               "ConmonPid": 1603,
          "ConmonPidFile": "/run/user/1000/containers/overlay-containers/2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422/userdata/conmon.pid",
          "PidFile": "/run/user/1000/containers/overlay-containers/2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422/userdata/pidfile",
               "PidMode": "private",
               "PidsLimit": 0,
[student@workstation ~]$ podman inspect myhttpd | grep -i \"Pid\":
               "Pid": 1614,
[student@workstation ~]$ podman inspect myhttpd | grep -i \"Pid\": | awk -F: '{print $1}'
               "Pid"
[student@workstation ~]$ podman inspect myhttpd | grep -i \"Pid\": | awk -F: '{print $2}'
 1614,
[student@workstation ~]$ podman inspect myhttpd | grep -i \"Pid\": | awk -F: '{print $2}' | sed 's/,//'
 1614
 [student@workstation ~]$ ps -ef | grep 1614
 101000      1614    1603  0 14:31 ?        00:00:00 httpd -D FOREGROUND
 101000      1724    1614  0 14:31 ?        00:00:00 /usr/bin/cat
 101000      1725    1614  0 14:31 ?        00:00:00 /usr/bin/cat
 101000      1726    1614  0 14:31 ?        00:00:00 /usr/bin/cat
 101000      1727    1614  0 14:31 ?        00:00:00 /usr/bin/cat
 101000      1728    1614  0 14:31 ?        00:00:00 httpd -D FOREGROUND
 101000      1734    1614  0 14:31 ?        00:00:00 httpd -D FOREGROUND
 101000      1736    1614  0 14:31 ?        00:00:00 httpd -D FOREGROUND
 101000      1752    1614  0 14:31 ?        00:00:00 httpd -D FOREGROUND
 101000      1753    1614  0 14:31 ?        00:00:00 httpd -D FOREGROUND
 student     2355    2023  0 14:54 pts/0    00:00:00 grep --color=auto 1614
----

Because the default output from `podman inspect` is a JSON object, tools that are built to parse JSON might be less problematic.  Consider the `jq` utility:

[source,bash]
----
[student@workstation ~]$ podman inspect myhttpd | jq
(lots of output)
[student@workstation ~]$ podman inspect myhttpd | jq | head
----

To filter the output stream using `jq` *filters* can be applied based on the object and the values you are interested in.

It's best to understand JSON a bit first.

*JSON* = JavaScript Object Notation
It is way to organize/structure data in a readable format.  This is primarly done through a list of "key" and "value" pairs in the format:

[source,bash]
----
"Key1": "value1",
"Key2": "value2",
...etc...
----

The *value* can be any of the following types:

* *String*: Several plain text characters which usually form a word enclsed in quotes " "
* *Boolean*: Value will be either true or false.
* *Number*: An integer
* *Object*: An associative array of key/value pairs ... a "dictionary"   {    }
* *Array*: An associative array of values ... a "list"   [     ]

Here are some examples from the `podman inspect` output:

[source,bash]
----
[student@workstation ~]$ podman inspect myhttpd | jq | less
[
  {
    "Id": "2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422",
    "Created": "2022-09-21T13:58:47.711790266-04:00", <---------------------  STRING
    "Path": "container-entrypoint",
    "Args": [       <-------------------------------------------------------  ARRAY
      "/usr/bin/run-httpd"
    ],
    "State": {         <----------------------------------------------------- OBJECT
      "OciVersion": "1.0.2-dev",
      "Status": "running",
      "Running": true,    <-------------------------------------------------- BOOLEAN
      "Paused": false,
      "Restarting": false,
      "OOMKilled": false,
      "Dead": false,
      "Pid": 1614,  <-------------------------------------------------------- NUMBER
      "ConmonPid": 1603,
...SNIP...
----

Understanding these different value types is critical to parsing JSON.

With `jq` a filter can be defined which will parse the JSON input and return out the values for the keys identified in the filter.

As you see in the example above, some keys are nested inside an OBJECT.  Others are part of an ARRAY. Take note of this while you study some examples:

[source,bash]
----
[student@workstation ~]$ podman inspect myhttpd | jq
[
  {
    "Id": "2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422",
    "Created": "2022-09-21T13:58:47.711790266-04:00",
    "Path": "container-entrypoint",
    "Args": [
      "/usr/bin/run-httpd"
    ],
    "State": {
      "OciVersion": "1.0.2-dev",
      "Status": "running",
      "Running": true,
      "Paused": false,
      "Restarting": false,
      "OOMKilled": false,
      "Dead": false,
      "Pid": 1614,
...SNIP...
----

To parse this, notice that first line is *[* indicating that everything you see here is stored inside an ARRAY.
To filter any key therefore we must include *.[]* in the filter so that all the keys in this ARRAY are included.

[source,bash]
----
[student@workstation ~]$ podman inspect myhttpd | jq ".[]"
{
  "Id": "2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422",
  "Created": "2022-09-21T13:58:47.711790266-04:00",
  "Path": "container-entrypoint",
  "Args": [
    "/usr/bin/run-httpd"
  ],
  "State": {
    "OciVersion": "1.0.2-dev",
    "Status": "running",
    "Running": true,
    "Paused": false,
    "Restarting": false,
    "OOMKilled": false,
    "Dead": false,
    "Pid": 1614,
...SNIP...
----

The first three keys listed in this object have STRING values.  To return the value for one of them we can expand our filter:

[source,bash]
----
[student@workstation ~]$ podman inspect myhttpd | jq ".[] .Id"
"2c3c93d8cfe4cceadc359d98377ca24e7c87576b390a7d505c316369b8720422"
[student@workstation ~]$ podman inspect myhttpd | jq ".[] .Created"
"2022-09-21T13:58:47.711790266-04:00"
[student@workstation ~]$ podman inspect myhttpd | jq ".[] .Path"
"container-entrypoint"
----

For





[student@workstation ~]# man podman-inspect
